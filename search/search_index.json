{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Reject boilerplate. Embrace complexity.</p> <p><code>pytest-embrace</code> is a Pytest plugin-slash-metaframework offering:</p> <ul> <li>Convenient abstractions for parametrized tests</li> <li>Great DX with type hints everywhere</li> <li>Code generation with low effort</li> </ul> <p>This plugin's long-term goal is to be the FastAPI of Pytest plugins.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>If you know how to use dataclasses and Pytest fixtures, you're ready to use <code>pytest-embrace</code>.</p> <p>As is tradition:</p> <pre><code>pip install pytest-embrace  # use a virtualenv in your preferred fashion\n</code></pre>"},{"location":"#configure-your-test","title":"Configure your test","text":"<p>Like any pytest plugin, <code>pytest-embrace</code> is configured in <code>conftest.py</code>.</p> <p>There are 2 ingredients</p> <ol> <li>The \"case\" \u2013\u2013 which can be any class decorated with <code>builtins.dataclasses.dataclass</code>.</li> <li>The \"fixture\" \u2013\u2013 which is just a tricked out Pytest fixture to run assertions against your case.</li> </ol> <pre><code># conftest.py\nfrom dataclasses import dataclass\nfrom typing import Any, Callable\nfrom pytest_embrace import Embrace\n@dataclass\nclass Case:  # (1)\narg: str\nfunc: Callable[[str], Any]\nexpect: Any\nembrace = Embrace(Case)  # (2)\n@embrace.fixture  # (3)\ndef simple_case(case: Case):\nresult = case.func(case.arg)\nassert result == case.expect\nreturn result\n</code></pre> <ol> <li>A dataclass describes the schema of your test modules.In this case, modules will need to define the attributes (variables) <code>arg</code>, <code>func</code>, and <code>expect</code>.</li> <li>Create an <code>Embrace()</code> instance.The methods exposed on this class define the behavior and identity of tests who implement the schema.</li> <li>Create a fixture to run the tests.This fixture is just like any other, but with some under-the-hood stuff to enable code-generation, validation, discoverability, and module-parsing.</li> </ol>"},{"location":"#generate-a-test","title":"Generate a test","text":"<p>The <code>simple_case</code> fixture is the identity of this new flavor of test you've created.</p> <p>You could just make a module and reference <code>simple_case</code> in a test function or....</p> <p>You could run this:</p> <pre><code>pytest --embrace simple_case\n</code></pre> <p>And then paste the output (it's already in your clipboard) into a new file.</p> <pre><code># test_wow.py\nfrom typing import Any, Callable  # (1)\nfrom pytest_embrace import CaseArtifact\nfrom conftest import Case\narg: str\nfunc: Callable[[str], Any]\nexpect: Any\ndef test(simple_case: CaseArtifact[Case]) -&gt; None:\n...\n</code></pre> <ol> <li>\ud83d\ude2e Note how Embrace figured out the right imports for types!</li> </ol>"},{"location":"#run-the-test","title":"Run the test","text":"<p>Fill in the values (with the comfort of autocomplete / editor help):</p> <pre><code>from pytest_embrace import CaseArtifact\nfrom conftest import Case\narg = \"wow\"\nfunc = lambda x: x.upper() + \"!!\"\nexpect = \"WOW!!\"\ndef test(simple_case: CaseArtifact[Case]) -&gt; None:\n...\n</code></pre> <p>And run it by calling <code>pytest</code>.</p> <pre><code>============================= test session starts ==============================\nplatform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /Users/ains/repos/tso/embrace\nplugins: embrace-1.0.1\ncollected 1 item\n\ntest_wow.py .                                                            [100%]\n============================== 1 passed in 0.01s ============================\n</code></pre>"},{"location":"#codegen","title":"\ud83d\ude80 Powerful Code Generation","text":"<p>Skeleton tests are fine, but <code>Embrace()</code> offers another decorator: <code>@generator</code>.</p> <p><code>pytest-embrace</code> code generators allow you to dynamically create tests via command-line input.</p> <pre><code>@embrace.generator\ndef my_gen(arg, expect, func):  # (1)\nreturn Case(\narg=arg,\nfunc=RenderText(func),  # (2)\nexpect=expect,\n)\n</code></pre> <ol> <li>Arguments to the function will be provided via CLI and parsed as JSON.</li> <li><code>RenderText(value)</code> lets you interpolate any valid python expression into your tests.</li> </ol> <p>With a slightly different form of argument to <code>--embrace</code>, you can provide <code>arg</code>, <code>expect</code>, and <code>func</code> and eliminate boilerplate completely.</p> <pre><code>pytest --embrace 'simple_case:my_gen arg=foo expect=3 func=len'\n</code></pre> <p>The above will generate this:</p> <pre><code>from collections.abc import Callable\nfrom typing import Any\nfrom pytest_embrace import CaseArtifact\nfrom conftest import Case\narg = \"foo\"\nfunc = len\nexpect = 3\ndef test(simple_case: CaseArtifact[Case]) -&gt; None:\n...\n</code></pre> <p>This only scratches the surface of <code>@generator</code> and code-rendering utilities.</p>"},{"location":"#validation-for-free","title":"Validation for Free","text":"<p>If you write a test that doesn't conform to the shape of your dataclass...</p> <pre><code>arg = b\"Accidental bytes\"\nfunc = lambda x: x.upper() + \"!!\"\nexpect = \"ACCIDENTAL BYTES!!\"\n</code></pre> <p>you get reprimanded right away.</p> <pre><code>E   pytest_embrace.exc.CaseConfigurationError: 1 invalid attr values in 'test_wow':\nE       Variable/Arg 'arg' should be of type str\n</code></pre>"},{"location":"#when-would-i-use-this","title":"When would I use this?","text":"<p>The pattern employed by <code>pytest-embrace</code> could technically be applied to any unit tests.</p> <p>In practice, however, it does best when:</p> <ul> <li>You have enormously tall parametrized tests that have become hard to grok and maintain.</li> <li>You are testing a consistent interface at a high level (think API endpoints) that rely on external state (like databases).</li> <li>And you've realized over time that all those tests are pretty much the same... but nuance makes parametrizing hard and you resign yourself to long breadcrumb trails of fixtures that may-or-may-not actually be used by your tests and just like... \ud83d\ude24 ugh.</li> <li>You like type safety, generating code, iterating quickly, testing exhaustively, and being DRY.</li> </ul>"},{"location":"#learn-more","title":"Learn More","text":"<p>Check out the feature-by-feature guide.</p>"},{"location":"about/","title":"About","text":"<p>Pytest Embrace is a formalism born from patterns used at Amper to bring functional tests to old, under-tested, complex backend applications in a way that would still be Nice for newer repos to build their foundation on.</p>"},{"location":"about/#philosophy","title":"Philosophy \ud83d\udca1","text":"<ol> <li> <p>Table-oriented (parametrized) tests are indespensible.</p> </li> <li> <p>Type hints and modern Python dataclasses are very good.</p> </li> <li> <p>As sayeth the Zen:</p> </li> </ol> <pre><code>Flat is better than nested.\nSparse is better than dense.\n...\nThere should be one-- and preferably only one --obvious way to do it.\n...\nNamespaces are one honking great idea -- let's do more of those!\n</code></pre> <ol> <li> <p>Code generation is really underrated.</p> </li> <li> <p>The wave of type-driven Python tools is very cowabunga\u2013\u2013and only just beginning \ud83d\udca1</p> </li> </ol>"},{"location":"about/#background","title":"Background","text":"<p>Underneath it all, this plugin/framework is a love letter to Pytest's parametrization feature.</p> <p>Parametrization is what makes Pytest really great. It works fantastically well for testing interfaces that can be expressed as <code>Given &lt;some_input&gt; expect &lt;some_output&gt; because &lt;some_reason&gt;</code>. Given, expected, should.</p> <p>But eventually, when you're testing at a higher level than simply calling code you've written, that pattern craps out. Tests that rely on live databases are a great example of this. Pytest handles this gracefully, as it's just Python code and you can write whatever you want.</p> <p>But that, too, becomes a problem: You can write whatever you want. The snare of arbitrariness leaves you with a mess of redundant, inconsistent fixtures floating around. With vanilla pytest fixtures, you're hung out to dry. If you want to get the structure and consistency of parametrized tests back, you're forced to either write a big ball of mud or learning the hooks API. Which you should at some point! But it's always felt like overkill for one-offs</p> <p>The idea with <code>pytest-embrace</code> is to create a looser and more nuance-friendly approach to fixtures and tests. while lowering the bar for leveraging more advanced Pytest test-generation features.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p><code>pytest-embrace</code> employs some non-neglibible trickery and some design decisions you may find odd.</p>"},{"location":"faq/#why-dataclasses","title":"Why dataclasses?","text":"<ul> <li>Use the platform.</li> </ul>"},{"location":"faq/#strongly-typed-modules","title":"Strongly typed modules??","text":"<ul> <li>Yep. Pydantic.</li> </ul>"},{"location":"faq/#whats-with-the-name","title":"What's with the name?","text":"<ul> <li>Embrace complexity.</li> </ul>"},{"location":"semantics/","title":"The Semantics of an Embrace Test","text":"<p>Read on only if you find academic stuff interesting.</p> <p>This page goes over the broad strokes of how module tests are put together.</p> <p>It's a formal-ish walkthrough of the guaranteed behaviors offered by tests that use this framework.</p> <p>If you just want to use the framework, check out Usage or Reference.</p> <p>pytest-embrace does not do a lot of magic.</p> <p>It simply uses the attributes of a module that Pytest would have picked up anyway to generate tests. This feature is well-documented but under-loved.</p> <p>Pytest says \"You can use variables in module scope as a part of your testing mechanism\" and pytest-embrace responds \"Ok! Let's formalize that.\"</p>"},{"location":"semantics/#the-formalism","title":"The Formalism","text":"<p>Over the years of experimentation and expansion, this framework has settled into these 6 tenets:</p> <ol> <li>Tests have a schema defined by some class.</li> <li>Test schemas are bound to a special Pytest fixture.</li> <li>Modules implement the schema by requesting that fixture and defining free variables.</li> <li>A test module may contain a literal list of the class it implements.</li> <li>Members of the list can inherit certain attributes defined in module scope.</li> <li>The module can inherit certain attributes from the test file name.</li> </ol> <p>Let's break them down with an example.</p>"},{"location":"semantics/#1-tests-have-a-schema-defined-by-some-class","title":"1. Tests have a schema defined by some class.","text":"<p>With the framework, that's just a dataclass.</p> <pre><code>@dataclass\nclass FooTestCase:\ngiven_word: str\ncoefficient: int\nexpected_word: str\n</code></pre> <p>The dataclass describes the schema of inputs and expected outputs of some test.</p>"},{"location":"semantics/#2-test-schemas-are-bound-to-a-special-pytest-fixture","title":"2. Test schemas are bound to a special Pytest fixture.","text":"<p>The \"binding\" is done with the <code>pytest_embrace.Embrace</code> class and its <code>.fixture</code> decorator.</p> <pre><code>emb = Embrace(FooTestCase)\n@emb.fixture\ndef foo_case(case: FooTestCase) -&gt; str:\nresult = case.given_word * case.coefficient\nassert result == case.expected_word\nreturn result\n</code></pre> <p>The fixture uses the attributes of a <code>FooTestCase</code> to run a test.</p>"},{"location":"semantics/#3-modules-implement-the-schema-by-requesting-that-fixture-and-defining-free-variables","title":"3. Modules implement the schema by requesting that fixture and defining free variables.","text":"<p>A fixture \"request\" in Pytest parlance is just a reference to its name in a test function signature.</p> <pre><code># test_something.py\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p>Since <code>foo_case</code> makes assertions and whatnot, the test doesn't strictly need a body.</p> <p>Take note of the <code>CaseArtifact</code></p> <p>The framework wraps the return value of your test and the case instance in this object. This enables introspection in the body of <code>test</code> and leaves room for us to add extra goodies in the future.</p> <p>To finish the implementation, define the required attributes of your case as module-scoped variables.</p> <pre><code># test_something.py\ngiven_word = \"hi\"\ncoefficient = 2\nexpected_word = \"hihi\"\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p>This is as far as you need to go to implement a test module.</p> <p>After this, we'll be looking at relatively-more-advanced (and very useful) features.</p>"},{"location":"semantics/#4-a-test-module-may-contain-a-literal-list-of-the-class-it-implements","title":"4. A test module may contain a literal list of the class it implements.","text":"<p>The reason you'd do this is to run many parametrized tests from your module.</p> <p>In embrace parlance, that would (by default) be a variable named <code>table</code> that is an instance of <code>list[FooTestCase]</code>.</p> <pre><code># test_something.py\ntable = [\nFooTestCase(\ngiven_word=\"hi\",\ncoefficient=2,\nexpected_word=\"hihi\",\n),\nFooTestCase(\ngiven_word=\"hi\",\ncoefficient=3,\nexpected_word=\"hihihi\",\n),\n]\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p><code>test_something.py</code> has gone from 1 passing test to 2.</p>"},{"location":"semantics/#5-members-of-the-list-can-inherit-certain-attributes-defined-in-module-scope","title":"5. Members of the list can inherit certain attributes defined in module scope.","text":"<p>This expands on tenet #4. <code>table</code> is useful for grouping related functionality, but can introduce repetition.</p> <p>In the above example, <code>given_word = \"hi\"</code> in both test cases. It would be preferable to declare that value only once, sill all tests in <code>table</code> use it.</p> <p>To create this behavior, use the <code>trickles()</code> field specifier on the schema class.</p> <pre><code>@dataclass\nclass FooTestCase:\ngiven_word: str = trickles()\ncoefficient: int\nexpected_word: str\n</code></pre> <p>The above change causes a declaration of <code>given_word</code> in module scope to \"trickle down\" into members of <code>table</code> that do not specify a value for it themselves. The test file can now be written this way:</p> <pre><code># test_something.py\ngiven_word=\"hi\"\ntable = [\nFooTestCase(\ncoefficient=2,\nexpected_word=\"hihi\",\n),\nFooTestCase(\ncoefficient=3,\nexpected_word=\"hihihi\",\n),\n]\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p>If a test is added that needs a different value for <code>given_word</code>, it can be passed as normal to \"override\" the default.</p> <pre><code># test_something.py\ngiven_word=\"hi\"\ntable = [\n# omitted for brevity...\nFooTestCase(\ngiven_word=\"yo\"\ncoefficient=5,\nexpected_word=\"yoyoyoyoyo\",\n),\n]\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p>Overriding can be disallowed by passing <code>no_override=True</code> to <code>trickles</code>.</p>"},{"location":"semantics/#6-the-module-can-inherit-certain-attributes-from-the-test-file-name","title":"6. The module can inherit certain attributes from the test file name.","text":"<p>Naming many test modules can be difficult, as arbitrary names can drift from the intent of the test.</p> <p>In order to address this, a schema can extract substrings from a test file's name.</p> <p>This is accomplished by using the <code>derive_from_filename()</code> field specifier.</p> <pre><code>@dataclass\nclass FooTestCase:\ngiven_word: str = derive_from_filename()\ncoefficient: int\nexpected_word: str\n</code></pre> <p>By default, this extracts everything after <code>test_</code> in the name of a file.</p> <p>If the name of <code>test_something</code> was changed to <code>test_hi</code>, then the module-scoped value of <code>given_word</code> can be omitted.</p> <pre><code># test_hi.py\ntable = [\nFooTestCase(\ncoefficient=2,\nexpected_word=\"hihi\",\n),\nFooTestCase(\ncoefficient=3,\nexpected_word=\"hihihi\",\n),\n]\ndef test(foo_case: CaseArtifact[FooTestCase]):\n...\n</code></pre> <p>Unlike <code>trickles()</code>, the value of a <code>derive_from_filename()</code> field can not be overridden.</p> <p>However, you're not limited to strings. The <code>parse</code> keyword arg for <code>derive_from_filename</code> takes a <code>Callable[[str], Any]</code> that receives the substring. The substring can be used to, for example, call <code>getattr</code> on some module or create an instance of some object using the string.</p>"},{"location":"semantics/#in-short","title":"In short","text":"<p>\"Module tests\" are not a formal thing.</p> <p>They really ought to be, because:</p> <ul> <li>\"Flat is better than nested and \"Namespaces are a honking great idea\" as they say in the Python manifesto</li> <li>Markup-like tests (with minimal logic) are easy to read, think about, and \u2013\u2013most importantly\u2013\u2013 generate.</li> <li>Pytest already made the tool, so let's use it!</li> <li>Testing this way has made a big difference at my work.</li> </ul> <p>Try <code>pytest-embrace</code> and let me know what you think! I think you'll like it. \ud83d\ude04</p>"},{"location":"two-to-three/","title":"Handling the API Change","text":"<p>3.0 is not backwards compatible at all</p> <p>The <code>register_case_runner</code> and <code>caller_fixture_factory</code> methods will raise exceptions that prompt you to migrate. In future releases, they will be removed completely.</p>"},{"location":"two-to-three/#background","title":"Background","text":"<p>In <code>pytest-embrace&lt;=3.0</code>, module test fixtures were created in two steps.</p> <pre><code>@dataclass\nclass MyCase:\nattr: str\nemb = Embrace(MyCase1)\n# STEP 1 -&gt; Create a 'runner'\n@emb.register_case_runner\ndef runner(case: MyCase1, fix: str) -&gt; None:\npass\n# STEP 2 -&gt; Create a 'caller'\nmy_case = emb.caller_fixture_factory(\"my_case\")\n</code></pre> <p><code>runner</code> and <code>caller</code> represented two distinct fixtures.</p> <p>Continued development and usage of the framework has revealed that this distinction is totally useless.  It's boilerplate and we hate boilerplate.</p> <p>In versions 3.0 and above, the <code>Embrace</code> class has a method called <code>fixture</code> that combines the two previous methods.</p> <pre><code>@dataclass\nclass MyCase:\nattr: str\nemb = Embrace(MyCase1)\n@emb.fixture\ndef my_case(case: MyCase1, fix: str) -&gt; None:\npass\n</code></pre> <p>This is more idiomatic with how Pytest usually works and gets rid of the confusing extra moving part of a \"caller fixture.\"</p>"},{"location":"two-to-three/#migrating","title":"Migrating","text":"<p>It's easy!</p> <ol> <li>Delete the fixture defined with <code>caller_fixture_factory</code></li> <li>Change the name of the function decorated with <code>register_case_runner</code> to the name formerly assigned to the result of <code>caller_fixture_factory</code></li> <li>Change <code>register_case_runner</code> to <code>fixture</code></li> </ol> <p>All done! \ud83c\udf89</p>"},{"location":"reference/api/","title":"API Reference","text":"<p>Find information here about the <code>pytest_embrace</code> module and its tools for designing, running, and writing tests.</p>"},{"location":"reference/api/#designing-cases","title":"Designing Cases","text":"<p>All of these are exposed in <code>pytest_embrace</code>. Use them in your case <code>dataclass</code>.</p>"},{"location":"reference/api/#trickles","title":"<code>trickles()</code>","text":"<p>Marks an attribute as one that can 'trickle down' from module scope into table cases as a default value.</p> <ul> <li>Mirrors the signature of <code>dataclasses.field</code> and is used in the same way.</li> <li>Adds 1 extra optional keyword-only argument: <code>no_override: bool</code> (default: <code>False</code>)</li> <li>With <code>no_override = True</code>, members of <code>table</code> can't override the module-level value of that attribute.</li> </ul>"},{"location":"reference/api/#derive_from_filename","title":"<code>derive_from_filename()</code>","text":"<p>Marks an attribute as derived from the name of an enclosing test file.</p> <ul> <li>Unlike <code>trickles()</code>, can't be oeverridden.</li> <li>Similar to trickles, all members of <code>table</code> inherit the value derived from the filename.</li> <li>Adds 2 extra optional keyword-only arguments</li> <li><code>pattern: str</code> (default: <code>[\\w\\.]*test_([\\w].*)</code>)<ul> <li>This is used to extract a substring from a test filename.</li> <li>Note: The <code>.py</code> extension is not looked at.</li> <li>Default extraction is everything after the <code>test_</code> prefix.</li> </ul> </li> <li><code>parse: Callable[[str], Any]</code> (default: <code>lambda s: s</code>)<ul> <li><code>parse</code> leverages the extracted substring to define anything you want.</li> <li>A example would be <code>parse = lambda s: getattr(some_module, s)</code></li> </ul> </li> </ul>"},{"location":"reference/api/#running-tests","title":"Running Tests","text":"<p>All of these are exposed in <code>pytest_embrace</code>. Use them to create a fixture to run your tests and inspect their results.</p>"},{"location":"reference/api/#embrace","title":"<code>Embrace</code>","text":"<p>The entrypoint for creating test cases from a dataclass.</p> <p>Register a dataclass as a module test schema and create a configurator for defining how tests that implement it will run.</p>"},{"location":"reference/api/#embracefixture","title":"<code>Embrace.fixture()</code>","text":"<p>Create the fixture that will handle the logic of running cases based on the class <code>Embrace</code> was instantiated with.</p> <ul> <li>Must take an argument called <code>case</code> that is type-hinted as <code>YourCaseType</code>.</li> <li>Otherwise behaves just like a normal Pytest fixture.</li> </ul>"},{"location":"reference/api/#caseartifact","title":"<code>CaseArtifact</code>","text":"<p>Wraps the instance of a case used for a test run along with whatever was returned by the case fixture.</p> <p>Allows for one-off introspection and debugging in tests.</p> <ul> <li>Exposes 2 properties:</li> <li><code>case</code>, the actual instance of your case object created during the test run</li> <li><code>actual_result</code>, the return value of the fixture.</li> </ul>"},{"location":"reference/api/#writing-tests","title":"Writing Tests","text":"<p>These aren't tools from the <code>pytest_embrace</code> module, but rather usage patterns.</p>"},{"location":"reference/api/#table","title":"<code>table</code>","text":"<p>When <code>pytest-embrace</code> sees a variable named <code>table</code> in a test file and that variable is an instance of <code>list[YourCaseType]</code>, the test is then parametrized with that list.</p> <p>If you declare a variable named <code>table</code> that is not an instance of <code>list[YourCaseType]</code>, it is treated normally.</p> <p>Info</p> <p>Right now, there is no explicit way to force a variable to be treated as <code>table</code>. Implementing such a feature is a high priority and should happen soon.</p>"},{"location":"reference/api/#typingannotated","title":"<code>typing.Annotated</code>","text":"<p>This is mostly a fun easter egg :)</p> <p>Warning</p> <p>This is available only in Python 3.9+</p> <p>When a variable in a case dataclass is type hinted with <code>Annotated</code> and the second argument to <code>Annotated</code> is a string, that string is injected as a comment in rendered copypasta tests.</p> <pre><code>class MyCase:\nfoo: Annotated[tuple, \"Foo is a foo!\"]\nemb = Embrace(MyCase)\n@emb.fixture\ndef my_case(case: MyCase): ...\n</code></pre> <p>Later, when generating a <code>my_case</code> test, a comment will appear in the generated output.</p> <pre><code># some_test.py\nfoo: str  # Foo is a foo!\ndef test(my_case): ...\n</code></pre>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>Find information about the command-line options exposed in <code>pytest</code> by <code>pytest-embrace</code>.</p>"},{"location":"reference/cli/#pytest-options","title":"Pytest Options","text":"<p>All of these are added to the <code>pytest</code> executable when <code>pytest-embrace</code> is installed.</p>"},{"location":"reference/cli/#-embrace-ls","title":"<code>--embrace-ls</code>","text":"<p>List all fixtures registered with <code>Embrace</code> along with their case objects.</p>"},{"location":"reference/cli/#-embrace-fixture_name","title":"<code>--embrace &lt;fixture_name&gt;</code>","text":"<p>Generate a skeleton test module and send it to your clipboard.</p>"},{"location":"reference/cli/#-embrace-fixture_namegenerator_name-argvalue","title":"<code>--embrace &lt;fixture_name&gt;:&lt;generator_name&gt; [&lt;arg&gt;=&lt;value&gt; ...]</code>","text":"<p>Runs the <code>Embrace.generator</code> decorated function named <code>&lt;generator_name&gt;</code> with the given<code>arg=value</code> pairs as keyword arguments.</p> <p>Given this:</p> <pre><code>e = Embrace(SomeCase)\n@e.fixture\ndef fix(): ...\n@e.generator\ndef gen(arg): ...\n</code></pre> <p>You can call this:</p> <pre><code>pytest --embrace 'fix:gen arg=something'\n</code></pre>"},{"location":"usage/","title":"Overview","text":"<p>Here you'll find some self-contained demonstrations to show of everything <code>pytest-embrace</code> can do.</p> <p>The surface area of <code>pytest-embrace</code> is relatively small.</p>"},{"location":"usage/code-generation/","title":"Noble Copypasta","text":"<p>Unit tests are the most tragic victim of haphazard copypasta.</p> <p>And they are a totally understandable thing to copy-paste.</p> <p>But it's fine until its not. Docstrings go stale, filenames make no sense, random unrelated state gets set up during tests, suites are repeated. Sadness ensues.</p> <p>That said, <code>Cmd + V</code> is very few keystrokes to get a new test case going. And that's appealing. So this plugin makes copypasta a first-class-feature!</p>"},{"location":"usage/code-generation/#pytest-options","title":"<code>pytest</code> Options","text":"<p><code>pytest-embrace</code> adds 2 extra options to the <code>pytest</code> command.</p> <ol> <li><code>--embrace-ls</code> will list out any caller fixtures that have been created in your codebase.</li> <li><code>--embrace &lt;fixture name&gt;</code> will print the scaffolding of a new test module to the console, and copy it to your clipboard. Check out an example in the Making Cases documentation.<ul> <li>There's also a second form that takes <code>&lt;fixture name&gt;[:&lt;generator name&gt; [&lt;key&gt;=&lt;value&gt; ...]]</code>, but we'll cover that later.</li> </ul> </li> </ol>"},{"location":"usage/code-generation/#comments-via-annotated","title":"Comments via <code>Annotated</code>","text":"<p>Limited use feature</p> <p>Since this feature uses <code>typing.Annotated</code>, Python versions &lt;=3.8 do not support it.</p> <p><code>Embrace()</code> test suites are complicated. Sometimes it may be difficult to grok the purpose of all the variables that show up in a generated module. So <code>pytest-embrace</code> provides a mechanisms for adding comments via Pep 593 annotations.</p> <p>Info</p> <p><code>Annotated[]</code> is a type-hint that takes the type you're hinting as its first arg, and then arbitrary stuff after. Like <code>Annotated[int, Whatever(), \"Anything works!\"]</code> counts as an <code>int</code>, but Library authors (me) can use those extra arguments to implement special behaviors.</p> <p>To add a comment to generated code, simply pass a string to <code>Annotated</code>:</p> conftest.py<pre><code>@dataclass\nclass CommentedCase:\nconfusing_attribute: Annotated[\nobject, \"This one is confusing. I have no further help for you :(\"\n]\ncomment_case_config = Embrace(CommentedCase)\n@comment_case_config.register_case_runner\ndef run_comment_case(case: CommentedCase) -&gt; None:\npass\ncomment_case = comment_case_config.caller_fixture_factory(\"comment_case\")\n</code></pre> <p>When you generate code for <code>comment_case</code>...</p> <pre><code>$ pytest --embrace comment_case\n</code></pre> <p>you get this:</p> <pre><code>from pytest_embrace import CaseArtifact\nfrom conftest import CommentedCase\nconfusing_attribute: object  # This one is confusing. I have no further help for you :(\ndef test(comment_case: CaseArtifact[CommentedCase]) -&gt; None:\n...\n</code></pre>"},{"location":"usage/designing-tests/","title":"Introduction","text":""},{"location":"usage/designing-tests/#complex-tools-for-complex-problems","title":"Complex Tools for Complex Problems","text":"<p>This framework excels when the following things about your tests are true:</p> <ul> <li>They are fairly repetitive\u2013\u2013like tests for a REST api or a database client.</li> <li>The behaviors being tested go beyond the scope of pure inputs and outputs.</li> <li>There are many contingencies for the behavior of an interface\u2013\u2013errors, mutations, calls to other services, etc.</li> </ul> <p>For this reason, the guide for <code>pytest-embrace</code> will deal with a SQLite database client. It's built in to Python, so no extra dependencies are needed to work through examples.</p> <p>All of this will be revisited later, but as a prelimanry heads up every piece of functionality will interact with this extremely complicated table of things:</p> <pre><code>create table things\n(\nname text,\nis_bread bool,\ntype text,\norigin text,\nrating int\n);\n</code></pre> <p>The client will consist of a single namespace, <code>crud.py</code>, full of functions that access and affect the <code>things</code> table. Tests will cover the various ways accessing and affecting that table can play out.</p>"},{"location":"usage/designing-tests/#a-quick-note-on-namespaces","title":"A Quick Note on Namespaces","text":"<p>With <code>pytest-embrace</code>, tests are written as Python modules\u2013\u2013individual files\u2013\u2013rather than as classes or functions.</p> <p>The structure of those files is determined by the user using dataclasses. The attributes of the class are expected to match up with any module that associates itself with it.</p> <p><code>pytest-embrace</code> uses <code>pytest</code> to glue together class namespaces with module namespaces, resulting in flat, markup-like test cases with an enforced structure and testing logic defined in exactly one place.</p> <p>Info</p> <p>In Python, a \"namespace\" is quite literally a \"space,\" such as a class or module, that affords access to \"names\", aka variables and attributes.</p> <p>Usually, class namespaces don't have anything to do with module namespaces. The latter are used almost exclusively to grab a bunch of related functionality at once:</p> <pre><code>import sys\nimport numpy as np\n</code></pre> <p>This is incredibly convenient and nice for accessing functionality via a clean interface. But for developers, Python does not provide any way to enforce the creation of such interfaces. The composition of a Python file's attributes is the wild west.</p>"},{"location":"usage/designing-tests/making-cases/","title":"Writing Tests","text":"<p>Pytest embrace is useful when that \"state of affairs\" goes beyond pure inputs and outputs. Code that relies on external databases is an excellent example.</p> <p>So before embarking on the test, we need some code to test.</p>"},{"location":"usage/designing-tests/making-cases/#system-under-test-a-database-client","title":"System Under Test: A Database Client","text":"<p>Specifically a SQLite client, as described in the Intro .</p> crud.py<pre><code>from sqlite3 import Connection\nclass NoRecordFoundError(Exception):\n...\ndef is_bread(conn: Connection, name: str) -&gt; bool:\ncursor = conn.execute(\n# in sqlite, `?` is used as a placeholder\n\"select is_bread from things where name = ?\",\n(name,),\n)\n(result,) = cursor.fetchone()\nreturn result == 1  # sqlite uses 1/0 for True/False\n</code></pre> <p>This function, which determines whether or not the record with the given <code>name</code> is bread or not. When the function is used, it presupposes</p> <ol> <li>A live database</li> <li>The existince of a database table called <code>things</code> with an <code>is_bread</code> column</li> <li>The presence of records in that table</li> </ol>"},{"location":"usage/designing-tests/making-cases/#setting-up-tests-with-normal-fixtures","title":"Setting Up Tests with Normal Fixtures","text":"<p>To test this, we start by making a pytest fixture to create a database and provide a connection to it.</p> conftest.py<pre><code>@pytest.fixture\ndef testconn() -&gt; Iterator[Connection]:\nconnection = connect(\":memory:\")\nconnection.execute(\n\"\"\"\n        create table things\n        (\n            name text,\n            is_bread bool,\n            type text,\n            origin text,\n            rating int\n        );\"\"\"\n)\nyield connection\nconnection.execute(\"drop table things\")\nconnection.close()\n</code></pre> <p>Now, we just need some data in there. Let's use another fixture!</p> conftest.py<pre><code>from sqlite3 import Connection\n@pytest.fixture\ndef testdata(testconn: Connection):\nrecords = (\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n)\ntestdb.executemany(\"insert into things values (?,?,?,?,?)\", [*records])\n</code></pre> <p>And now we're good to test:</p> test_crud.py<pre><code>def is_bread_true(testdata, testconn: Connection):\nassert is_bread(testconn, 'mirth') is False, \"Mirth is a feeling, not bread.\"\nassert is_bread(testconn, 'croissant') is True, \"A croissant is tasty bread.\"\n</code></pre>"},{"location":"usage/designing-tests/making-cases/#describing-the-state-of-affairs-with-a-dataclass","title":"Describing The State of Affairs with a Dataclass","text":"<p>In order to run the test, we needed a few things:</p> <ol> <li>A database with a table in it. This will apply to all the tests.</li> <li>Some known records to seed the DB and query against. This is unique to this test.</li> <li>A function we want to test</li> <li>Some args to pass our function.</li> <li>Some expectations for our function, including a assertion messages.</li> </ol> <p>How can this state of affairs be codified into a test case? Let's take a crack at it.</p> conftest.py<pre><code>from dataclasses import dataclass\n@dataclass\nclass CrudTestCase:\nseed_data: list[tuple]\ncrud_func: Callable[..., Any]\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str  # assertion message\n</code></pre> <p>Awesome. Now how will we run it?</p>"},{"location":"usage/designing-tests/making-cases/#configuring-the-test-run-with-embrace","title":"Configuring the Test Run with <code>Embrace()</code>","text":"<p>First, we need <code>Embrace</code>, and a runner.</p> conftest.py<pre><code>from sqlite3 import Connection\nfrom pytest_embrace import Embrace\ncrud_case_config = Embrace(CrudTestCase)\n@crud_case_config.fixture\ndef crud_case_runner(): ...\n</code></pre> <p>Passing a dataclass to <code>Embrace</code> gives us an object instance we can use to configure test cases based on the state of affairs we described.</p> <p>The <code>.register_case_runner</code> function ultimately creates a Pytest fixture, so we have access to any fixtures we've already defined.</p> <p>Additionally, it must receive an instance of the class you registered and all of its arguments must be typed.</p> <p>Our first pre-req for testing <code>is_bread</code> was an existing database. We already have a fixture for that: <code>testdb</code>. So we can just reference it!</p> conftest.py<pre><code>from sqlite3 import Connection\n@crud_case_config.fixture\ndef crud_case_runner(case: CrudTestCase, testdb: Connection):\n...\n</code></pre> <p>The <code>CrudTestCase</code> object has that <code>seed_data</code> attribute. Let's recycle some code from <code>testdata</code> (which we will no longer use, since it hardcoded data and each test will need to define its own).</p> conftest.py<pre><code>@crud_case_config.fixture\ndef crud_case_runner(case: CrudTestCase, testconn: Connection) -&gt; object:\ntestconn.executemany(\"insert into things values (?,?,?,?,?)\", [*case.seed_data])\n</code></pre> <p>And now we can put in a more generalized call to the function.</p> conftest.py<pre><code>@crud_case_config.fixture\ndef crud_case_runner(case: CrudTestCase, testconn: Connection) -&gt; object:\ntestconn.executemany(\"insert into things values (?,?,?,?,?)\", [*case.seed_data])\nresult = case.crud_func(*case.args)\nassert case.assert_return == result, case.should\nreturn result  # (1)\n</code></pre> <ol> <li>Take note of the return: It's the actual result of our function call. That'll come back into play later.</li> </ol>"},{"location":"usage/designing-tests/making-cases/#implement-the-test","title":"Implement The test","text":"<p>We now have all we need to start writing tests.</p>"},{"location":"usage/designing-tests/making-cases/#code-generation","title":"Code Generation","text":"<p><code>pytest-embrace</code> is as much about strict case composition as it is about code generation. So now that we have <code>crud_case</code> floating around, let's reference it at the command line:</p> <pre><code>pytest --embrace crud_case\n</code></pre> <p>You'll see this output:</p> <pre><code>============================= test session starts ==============================\nplatform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /Users/ains/repos/pytest-embrace\nplugins: embrace-1.0.1\ncollected 21 items\n\nCopying the following output to your clipboard:\n\nfrom pytest_embrace import CaseArtifact\n\nfrom conftest import CrudCase\n\nseed_data: list[tuple]\ncrud_func: typing.Callable[..., typing.Any]\nargs: tuple[typing.Any, ...]\nassert_return: typing.Any\nshould: str\n\ndef test(crud_case: CaseArtifact[CrudTestCase]) -&gt; None:\n    ...\n</code></pre> <p>The content of the test is in your clipboard, so go ahead and paste it in a new file.</p> <pre><code># for mac users...\npbpaste &gt; test_is_bread_false.py\n</code></pre> <p>The contents aren't perfect. Not all imports are solved (for now), but it's a strong start!</p> <p>Let's fill in the blanks, removing type hints as we go. What was formerly expressed as this:</p> <pre><code>def is_bread_true(testdata, testconn: Connection):\nassert is_bread('mirth') is False, \"Mirth is a feeling, not bread.\"\n</code></pre> <p>Is now this:</p> test_is_bread_false.py<pre><code>from pytest_embrace import CaseArtifact\nfrom conftest import CrudCase\nfrom crud import is_bread\nseed_data = (\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n)\ncrud_func = is_bread\nargs = (\"mirth\",)\nassert_return = False\nshould = \"Mirth is a feeling, not bread.\"\ndef test(crud_case: CaseArtifact[CrudTestCase]) -&gt; None:\n...\n</code></pre>"},{"location":"usage/designing-tests/making-cases/#iterating-sharing","title":"Iterating &amp; Sharing","text":"<p>Now let's do the second test.</p> <pre><code>pytest --embrace crud_case\npbpaste &gt; test_is_bread_true.py\n</code></pre> <p>Since this test will share a lot of DNA with the first one, it can be configured simply with the import system.</p> test_is_bread_true.py<pre><code>from pytest_embrace import CaseArtifact\nfrom conftest import CrudTestCase\n# shared DNA\nfrom test_is_bread_false import crud_func, seed_data\nargs = (\"croissant\",)\nassert_return = True\nshould = \"A croissant is tasty bread.\"\ndef test(crud_case: CaseArtifact[CrudTestCase]) -&gt; None:\n...\n</code></pre> <p>Attention</p> <p>While using imports this way is a cool trick to share test dependencies, it has proved somewhat controversial/finnicky in practice.</p> <p>In the next section and beyond we'll go over some other more structured approaches.</p> <p>Now we can run these as normal:</p> <pre><code>$ pytest\n=============================== test session starts ===============================\nplatform darwin -- Python 3.10.4, pytest-7.1.2, pluggy-1.0.0\nrootdir: /Users/ains/repos/pytest-embrace/docs/code-samples\nplugins: embrace-0.3.0\ncollected 2 items\n\ntest_is_bread_false.py .                                                    [ 50%]\ntest_is_bread_true.py .                                                     [100%]\n================================ 2 passed in 0.02s ================================\n</code></pre>"},{"location":"usage/designing-tests/making-cases/#the-artifact","title":"The Artifact","text":"<p>You'll notice very generated test function has this in its singature:</p> <pre><code>crud_case: CaseArtifact[CrudTestCase]\n</code></pre> <p>In the event that you want to do anything more after your runner has succeeded, you can access the generated <code>CrudTestCase</code> object in its <code>.case</code> property, and the return value from the runner in <code>.actual_result</code>. Maybe, for example, you want to pull in more fixtures for special-case assertions.</p> test_bread_true.py<pre><code>...\ncrud_func = is_bread\nargs = (\"mirth\",)\nassert_return = False\nshould = \"Mirth is a feeling, not bread.\"\ndef test(crud_case: CaseArtifact[CrudTestCase], testconn, caplog) -&gt; None:\nassert \"Today's non-bread discovery count is now 1\" in caplog.text\nassert crud_case.case.args[0] in caplog.text, \"The non-bread is mentioned by name\"\ncrud_case.case.crud_func(testconn, 'trees')\nassert \"Today's non-bread discovery count is now 2\" in caplog.text, (\n\"Repeated queries about non-bread increment the counter\"\n)\n</code></pre> <p>This \ud83d\udc46\ud83c\udffd won't pass because we don't have any logging. It's just to illustrate.</p>"},{"location":"usage/leveraging-filenames/","title":"Naming: From Liability to Asset","text":"<p>There are only two hard things in Computer Science: cache invalidation and naming things.</p> <p>-- Phil Karlton (via Martin Fowler)</p> <p>In the last section, using <code>trickles(no_override=True)</code> allowed us to restrict the test case we've been working on to testing one function at a time. This can help keep tests organized and focused, as all the tests that have to do with some function are all bundled together, and different functions can get their own files.</p> <p>But there's a major drawback here: naming. Right now it's fine. <code>is_bread()</code> is tested in <code>test_is_bread.py</code>. But what if we brilliantly renamed the function to <code>affirm_breadness</code>? Discoverability would wither and life would grow confusing.</p> <p><code>pytest_embrace</code> has another feature, similar to <code>trickles()</code>, that helps use filenames as data: <code>derive_from_filename()</code>. It is another wrapper around <code>dataclasses.field</code>. By default, it extracts the substring in the filename that follows the word <code>test_</code>.</p> <p>That means for <code>test_is_bread.py</code>, we could extract <code>is_bread</code>, which is a good start, but we need a specific function, not a string.</p> <p>Luckily, <code>derive_from_filename</code> takes a <code>parse</code> argument that lets us take that substring and do anything we want with it, ultimately returning any value.</p> <p>In our case, it can be used to find the right <code>crud</code> function based on the name of the test file.</p> test_is_bread.py<pre><code>import crud  # the namespace we test against\n@dataclass\nclass CrudTestCase:\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str  # assertion message\nseed_data: list[tuple[Any, ...]] = trickles()\n# tada!\ncrud_func: Callable[..., Any] = derive_from_filename(\nparse=lambda x: getattr(crud, x)\n)\ndef __str__(self) -&gt; str:\nreturn f\"{self.crud_func.__name__}{self.args} -&gt; {self.assert_return}\"\n</code></pre> <p>And we can remove the <code>crud_func</code> declaration from the test file.</p> test_is_bread.py<pre><code>from conftest import CrudTestCase\nseed_data = [\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n]\ntable = [\nCrudTestCase(\nargs=(\"mirth\",),\nassert_return=False,\nshould=\"Mirth is a feeling, not bread.\",\n),\nCrudTestCase(\nargs=(\"croissant\",),\nassert_return=True,\nshould=\"A croissant is tasty bread.\",\n),\n]\ndef test(crud_case):\n...\n</code></pre> <p>Now, even the name of the file will change over time with the system it's testing. And\u2013\u2013even better\u2013\u2013the naming convention of these test modules is saved from fickle human arbitrariness. \ud83d\udcaa\ud83c\udffd</p>"},{"location":"usage/tables-and-modules/","title":"From Modules to Tables to Both","text":"<p><code>pytest-embrace</code> allows you to define tests as Python modules whose schemas are defined as dataclasses.</p> <p>So far, more tests (and test coverage) just means more files. While this has benefits (most notably discoverability) it also can become tiresome, especially when testing the exact same functionality with a variety of different scenarios.</p>"},{"location":"usage/tables-and-modules/#table-tests","title":"Table Tests","text":"<p>Luckily the framework has a special behavior when it encounters a variable named <code>table</code> in your test modules: If the <code>table</code> refers to a list of instances of the dataclass you registered with <code>Embrace</code>, the framework will use <code>pytest.mark.parametrize</code> to run an independent test for each member of the list.</p> <p>The two tests that were written as two files in the previous section can be refactored to this:</p> test_is_bread.py<pre><code>from conftest import CrudTestCase\nfrom crud import is_bread\ntable = [\nCrudTestCase(\nseed_data=[\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n],\ncrud_func=is_bread,\nargs=(\"mirth\",),\nassert_return=False,\nshould=\"Mirth is a feeling, not bread.\",\n),\nCrudTestCase(\nseed_data=[\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n],\ncrud_func=is_bread,\nargs=(\"croissant\",),\nassert_return=True,\nshould=\"A croissant is tasty bread.\",\n),\n]\ndef test(crud_case):\n...\n</code></pre> <p>This is cool, but there's still a good bit of repetition, which we've been trying to avoid.</p> <p>We could lift some stuff into <code>SCREAMING_CONSTANTS</code> but that's not really a solution, it's just a well-liked bandaid. Good for preventing bugs, but not that helpful for our brains.</p> <p>Luckily, there is a solution!</p>"},{"location":"usage/tables-and-modules/#data-trickles-down","title":"Data Trickles Down","text":"<p>Let's take it way back to the definition of <code>CrudTestCase</code>.</p> conftest.py<pre><code>from typing import Callable, Any\nfrom pytest_embrace import trickles\n@dataclass\nclass CrudTestCase:\nseed_data: list[tuple[Any, ...]]\ncrud_func: Callable[..., Any]\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str\n</code></pre> <p>While <code>pytest-embrace</code> doesn't make you inherit from any kind of opinionated base class, it does come with some utilities for layering framework-specific behaviors into your cases.</p> <p>The first one is called <code>trickles()</code>. It's a wrapper around <code>dataclasses.field</code>.</p> <p>When you assign it to a property in your dataclass, it tells the framework to treat it specially:</p> <ul> <li>When a field on your test case class is assigned to <code>trickles()</code>...</li> <li>And you define a module with a <code>table</code>...</li> <li>Then at runtime, <code>pytest-embrace</code> will look for any \"trickled\" attributes in module scope before looking at the objects in <code>table</code>.</li> <li>If it finds that any table members have not been passed values for \"trickled\" attributes, those cases simply use the module-scoped value.</li> </ul> <p>So, let's make <code>crud_func</code> and <code>seed_data</code> trickle:</p> conftest.py<pre><code>from typing import Callable, Any\nfrom pytest_embrace import trickles\n@dataclass\nclass CrudTestCase:\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str\nseed_data: list[tuple[Any, ...]] = trickles()\ncrud_func: Callable[..., Any] = trickles()\n</code></pre> <p>Now, we can make the test suite like this:</p> test_is_bread.py<pre><code>from conftest import CrudTestCase\nfrom crud import is_bread\nseed_data = [\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n]\ncrud_func = is_bread\ntable = [\nCrudTestCase(\nargs=(\"mirth\",),\nassert_return=False,\nshould=\"Mirth is a feeling, not bread.\",\n),\nCrudTestCase(\nargs=(\"croissant\",),\nassert_return=True,\nshould=\"A croissant is tasty bread.\",\n),\n]\ndef test(crud_case):\n...\n</code></pre> <p>With this change, each member of <code>table</code> concerns itself exclusively with the things that are unique to that test, and the things they have in common are mentioned only one time. How DRY!</p> <p>By default, individual cases can override the module-scope value.</p> <p>We can make the first test fail by overriding its <code>crud_func</code>:</p> test_is_bread.py<pre><code>from conftest import CrudTestCase\nfrom crud import is_bread\nseed_data = [\n(\"mirth\", False, \"feeling\", \"prefontal cortex\", 5),\n(\"fear\", False, \"feeling\", \"prefontal cortex\", 0),\n(\"croissant\", True, \"food\", \"france\", 4),\n]\ncrud_func = is_bread\ndef _evil_func(*_):\nreturn \"FAILURE\"\ntable = [\nCrudTestCase(\nargs=(\"mirth\",),\nassert_return=False,\nshould=\"Mirth is a feeling, not bread.\",\n),\nCrudTestCase(\ncrud_func=_evil_func,  # &lt;- uh oh.\nargs=(\"croissant\",),\nassert_return=True,\nshould=\"A croissant is tasty bread.\",\n),\n]\ndef test(crud_case):\n...\n</code></pre>"},{"location":"usage/tables-and-modules/#being-strict","title":"Being Strict","text":"<p>One of the emergent downsides of table tests is that they're very prone to bloat.</p> <p>It's easy to copypaste a member from an existing table and add it to the bottom. Easy!</p> <p>But this library exists to keep you organized! In the example above, <code>seed_data</code> and <code>crud_func</code> both trickle down. The former makes sense: It certainly stands to reason that <code>is_bread</code> should be tested with different preexisting data. As for <code>crud_func</code>... it's pretty nice to have one file concern itself with one API. Letting in random functions would totally kill the vibe and let this file get unweildy.</p> <p>The only argiment that <code>trickles</code> takes and <code>field</code> does not is: <code>no_override</code>.</p> conftest.py<pre><code>@dataclass\nclass CrudTestCase:\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str\nseed_data: list[tuple[Any, ...]] = trickles()\ncrud_func: Callable[..., Any] = trickles(no_override=True)\n</code></pre> <p>With <code>no_override=True</code>, the second test above becomes illegal. When you run the tests now, you'll get a <code>CaseConfigurationError</code>.</p>"},{"location":"usage/tables-and-modules/#an-aside-on-test-output","title":"An Aside on Test Output","text":"<p>If you ran that last example, you probably saw some pretty unruly test output:</p> <pre><code>E   pytest_embrace.exc.CaseConfigurationError: In table[1]:CrudTestCase(args=('croissant',), assert_return=True, should='A croissant is tasty bread.', seed_da\nta=[('mirth', False, 'feeling', 'prefontal cortex', 5), ('fear', False, 'feeling', 'prefontal cortex', 0), ('croissant', True, 'food', 'france', 4)], crud_fun\nc=&lt;function &lt;lambda&gt; at 0x105145d80&gt;), 'crud_func' is set, but 'crud_func' is defined at the module level as well and configured as as no_override. Accept the\n default or change the config.\n</code></pre> <p>What you're seeing is just the default <code>str</code> of <code>CrudTestCase</code>. Defining <code>__str__</code> to something pretty drastically improves things:</p> conftest.py<pre><code>@dataclass\nclass CrudTestCase:\nargs: tuple[Any, ...]\nassert_return: Any\nshould: str  # assertion message\nseed_data: list[tuple[Any, ...]] = trickles()\ncrud_func: Callable[..., Any] = trickles(no_override=True)\ndef __str__(self) -&gt; str:\nreturn f\"{self.crud_func.__name__}{self.args} -&gt; {self.assert_return}\"\n</code></pre> <p>The failure looks much better:</p> <pre><code>E   pytest_embrace.exc.CaseConfigurationError: In table[1]:_evil_func('croissant',) -&gt; True,\n'crud_func' is set, but 'crud_func' is defined at the module level as well and configured as as no_override. Accept the default or change the config.\n</code></pre> <p>And running <code>pytest -v</code> after fixing the config error shows each member of the <code>table</code> nicely.</p> <pre><code>test_is_bread_table.py::test[is_bread('mirth',) -&gt; False] PASSED                                                                                       [ 50%]\ntest_is_bread_table.py::test[is_bread('croissant',) -&gt; True] PASSED                                                                                   [100%]\n</code></pre>"}]}